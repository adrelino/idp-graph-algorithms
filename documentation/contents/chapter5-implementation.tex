\chapter{Implementation}\label{ch:5}

\newenvironment{ssfont}{\fontfamily{lmss}\selectfont}{\par}

The implementation is an evolution of previous web applications for the visualization of graph algorithms \cite{storz2013idp,velden2014idp,sefidgar2015idp,becker2015idp,zoennchen2015idp}. However, the requirements for graphs with arbitrary resources, a secondary visualization layer and high interactivity urged us to reimplement large parts of the existing codebase using different technologies \refSec{sec:technologies} while still maintaining the same look and feel. In the process, a complete understanding of the interplay between the different components was acquired, which allowed us to refactor them systematically to achieve a better software design \refSec{sec:design}. This chapter concludes with an installation or deployment manual for the developed web applications \refSec{sec:installation}.

\section{Web technologies}\label{sec:technologies}
Web technologies form the basis of our implementation. The excellent Mozilla Developer Network (MDN)\footnote{\url{https://developer.mozilla.org/docs/Web}} is a great reference, which subdivides the technologies into basics \refSec{sec:basics}, scripting \refSec{sec:script} and graphics \refSec{sec:graphics}. Furthermore, we use two JavaScript Software libraries \refSec{sec:libraries} to facilitate certain tasks.

\subsection{Basics: HTML, CSS, HTTP and AJAX}\label{sec:basic}
The HyperText Markup Language (HTML) is used to define the static \textit{content} of the webpage. Each webpage contains just one HTML file, \texttt{\href{http://www.adrian-haarbach.de/idp-graph-algorithms/implementation/maxflow-push-relabel/index_en.html}{maxflow-push-relabel/index\_en.html}} or \texttt{\href{http://www.adrian-haarbach.de/idp-graph-algorithms/implementation/spp-rc-label-setting/index_en.html}{spp-rc-label-setting/index\_en.html}}, for all its static content. These serve as the entry point for our single-page web application and contain all language-specific features. For localization purpuses, one needs to modify only this file. Cascading Style Sheets (CSS) are used to describe the \textit{appearance or presentation} of the content on the webpage. They can be used both for HTML (\texttt{\href{http://www.adrian-haarbach.de/idp-graph-algorithms/implementation/library-d3-svg/css/style.css}{library-d3-svg/css/style.css}}) and for SVG Graphics such as our graph (\texttt{\href{http://www.adrian-haarbach.de/idp-graph-algorithms/implementation/library-d3-svg/css/graph-style.css}{library-d3-svg/css/graph-style.css}}). The Hypertext Transfer Protocol (HTTP) is used to deliver HTML and other hypermedia documents on the Web. The basic files we need everywhere are statically linked from within our HTML page with \texttt{<link href="...">} for CSS and \texttt{<script src="...">} for JavaScript files. By using asynchronous JavaScript and XML (AJAX), we can issue HTTP requests dynamically, for example when selecting another sample graph, without the need to completely reload the entire page.

\subsection{Scripting: JavaScript, DOM, Web APIs, HTML5 and Node.js}\label{sec:script}
JavaScript is the scripting language that runs natively in a browser. It was originally developed to  add interactivity and other dynamic features to a webpage. This is achieved by manipulating the Document Object Model (DOM), a programming interface for HTML, XML and SVG documents. It provides a structured representation of the document as a tree which can be modified and extended using JavaScript and other languages. The JavaScript language contains standard built-in global objects, e.g. the JSON\footnote{\url{https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/JSON}} object with methods for parsing JavaScript Object Notation (JSON), used for serialization of algorithm state to provide the replay functionality. Web Application Programming Interfaces (Web APIs) complement the standard built-in global objects to provide a way to access the browser's advanced functionality programmatically. We make use of this functionality to serialize and download dynamically generated SVG using \texttt{XMLSerializer.serializeToString()}\footnote{\url{https://developer.mozilla.org/docs/Web/API/XMLSerializer}} and \texttt{WindowBase64.btoa()}\footnote{\url{https://developer.mozilla.org/docs/Web/API/WindowBase64}} and of the \texttt{FileReader.readAsText()}\footnote{\url{https://developer.mozilla.org/docs/Web/API/FileReader}} for the local graph upload functionality. Because of their importance, the APIs and the DOM are now fundamental parts of the new HTML5 specification, which extends the HTML markup with new syntactic features such as \texttt{<video>, <audio>, <canvas>} and \texttt{<svg>} tags and the support for mathematical formulas with MathML markup.

\subsubsection{Server-side scripting using Node.js}
However, the JavaScript language itself is not restricted to client-side scripting in the  browser, only the specific parts we just discussed above. The standard for JavaScript is defined as ECMAScript. As such, it can also be used for server-side scripting using the Node.js host environment. In fact, there is nowadays a huge JavaScript ecosytem consisting of different open-source packages that allows to use JavaScript for all kinds of programming purposes. We used the command line interface applications NPM as package manager and Grunt as a build tool to implement a simple web-server for development purposes. This circumvents some browsers's security settings of disallowing AJAX requests when files are served locally, which would prohibit us from loading different graphs.\footnote{In fact, this restriction is only present in Google Chrome and can be circumvented when starting it with the \texttt{-{}-allow-file-access-from-files} flag. The latest versions of Firefox and Safari don't seem to have this restriction anymore as was already observed by \cite{feil2016idp}. Another alternative would be to install a production-quality web-server such as Apache, but this is overkill during development.}

\subsubsection{JavaScript - a fully featured programming language with rich features}
JavaScript is not just a lightweight scripting language, it is actually a fully featured programming language. It has matured a lot during its standardization process, a complete reference is given by \cite{flanagan2011javascript}. It is an interpreted, prototype-based, multi-paradigm dynamic scripting language with first-class functions. It supports imperative, object-oriented, and declarative or functional programming styles. As such, it is actually superior to more traditional languages such as Java or C++, which only made a functional programming style possible in their latest editions of Java 7 and C++ 11 through \textit{lambdas}. The object-oriented part of JavaScript works a little different than in the traditional languages, because it relies on prototype object based inheritance instead of class based inheritance. A good introduction to the language suitable for beginners covering the important concepts of scope and closure of the functional style and prototypal-based inheritance of the object-oriented style is given by \cite{haverbeke2015eloquent,resig2013secrets}.
While being an incredibly expressive and flexible language, the original creators of JavaScript initially made a few bad design decisions, but it is too late to remove them completely from the language nowadays. This is why it has become the \textit{world's most misunderstood programming language} according to Douglas Crockford, whose advice is to stick to \textit{JavaScript: The Good Parts} \cite{crockford2008javascript}, which is the title of his advanced book about the language features one should use and the ones to be avoided.
Since we partly follow the object-oriented programming style to create reusable software components, we had to deal with good software design, which will be covered later \refSec{sec:design}. To harness the full power of JavaScript effectively, e.g. with statics, singletons and different code-reuse patterns, we recommend \cite{herman2012effective}.

\subsection{Graphics: SVG vs. Canvas}\label{sec:graphics}
SVG and Canvas are both part of HTML5 and used to display interactive graphics on a webpage. 

The previous projects were based on \textbf{Canvas}, which allows for dynamic, scriptable rendering of \textit{raster-based} 2D graphics using JavaScript. It is a \textit{low-level}, procedural model that updates a bitmap pixel by pixel using drawing routines. Once an object is drawn, it is forgotten by the browser. The complete scene thus has to be redrawn after any changes. The quality of the resulting bitmap is resolution dependent, leading to poor text rendering and scaling capabilities. 

On the other hand, Scalable Vector Graphics (\textbf{SVG}) is a \textit{high-level} language for describing \textit{vector-based} 2D graphics using XML notation, in complete analogy to HTML which describes page layout using XML notation. Similar to the HTML DOM which allows to access individual nodes of the page tree, individual shapes of the SVG vector graphic can be accessed and modified via an SVG DOM, the scene graph. This allows to modify and re-render only a subset of the scene. Furthermore, it allows to attach JavaScript event handlers to individual shapes, easing interaction capabilities like clicks on nodes and edges or resources in our graph editor. Because of its advantages over Canvas, the previous projects have lately been migrated to SVG \cite{feil2016idp} and all current projects already use our SVG implementation \cite{feil2016idp,fischer2016idp}, profiting from its new features.

All figures in this report are vector graphics. We did not need to take rasterized screenshots of our web-application to highlight aspects of our visualization concept because we implemented a download functionality for all SVG graphics. This allowed to reduce the file size of this report while all graphics have unlimited sharpness. This export functionality is an important contribution for future scientific publications in discrete math, because it allows to easily include high-quality graph drawings at minimal file size into any documentation.

Exporting the dynamically generated SVG from our webpage into this PDF document however requires some tricks. All styles regarding the appearance of nodes are defined in CSS files to be shared among different SVG graphics of the page. These need to be inlined into the \texttt{<defs>} section of the SVG DOM of each graphic before download and wrapped inside of a CDATA attribute so that line-breaks are ignored. In the same section, we also have to copy our shared arrowhead definitions for directed edges, since otherwise our exported graph would look like an undirected graph. The modified SVG DOM root node is serialized to string and base64 encoded using above Web API's so that it can be downloaded by a simple click on a link in the browser. 

The downloaded, standalone SVG file can be opened by browsers and image processing or vector graphics software. One can use free software such as Inkscape\footnote{\url{https://inkscape.org}} to convert the SVG vector graphic into a PDF vector graphic which is recognized by the \LaTeX{} command \texttt{\textbackslash includegraphics} used throughout this report.\footnote{However, there is a bug \url{https://bugs.launchpad.net/inkscape/+bug/811862} in Inkscape, it does not support the dominant-baseline CSS property and the text-anchor CSS style for vertical and horizontal text alignment. Thus, the labels for nodes and edges are misplaced directly on top of the edges. A workaround is to open the SVG with a browser and using the print dialog to save it to PDF. This PDF can then be opened with Inkscape and cropped, the previously mentioned problems are no longer present.}
%We provides a complete and convenient pipeline to draw graphs of arbitrary shape and with arbitrary resources using our graph editor, a way to visualize state of graph algorithms.  is  is that one can easily define graphs with arbitrary resources using our graph editor, One contribution of this work is thus that we 
\subsection{Libraries: jQuery, D3.js and MathJax}\label{sec:libraries}

JavaScript libraries such as jQuery, D3.js and MathJax were used to facilitate certain tasks.

%\subsection{JavaScript - the good parts}
%\subsection{SVG}

\section{Software design}\label{sec:design}% methods} %software algorithm design (high level)
We improved code quality and maintainability by adhering to object oriented programming best practices of \textit{high cohesion and low coupling} \refFigure{fig:coh}. The separation of the components now fits the \textit{Model-View-Controller (MVC)} design pattern \refFigure{fig:mvc}, which was already applied partially in previous work, even better. A good reference explaining how to apply these patterns using JavaScript is \cite{stefanov2010javascript}.
\begin{figure}
\centering
\begin{subfigure}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{fig/MVC-Process}
	\caption{Model-View-Controller(MVC)\footnotemark}
	\label{fig:mvc}
\end{subfigure}
\begin{subfigure}[b]{0.68\textwidth}
\begin{small}
\begin{ssfont}
\begin{itemize}
\item Cohesion refers to the degree to which the elements of a class belong together, suggestion is all the related code should be close to each other, so we should strive for \textbf{high cohesion} and bind all related code together as far as possible. It has to do with the elements \textit{within} the class. %\textbf{High cohesion} means a class should do only one thing, but very well.
\item Coupling refers to the degree to which the different classes depend on each other, suggestion is all modules should be independent as far as possible, that's why \textbf{low coupling}. It has to do with the elements \textit{among} different classes. %\textbf{low coupling} suggest that class should have least possible dependencies.
\end{itemize}
\end{ssfont}
\end{small}
\caption{high cohesion, low coupling\footnotemark}
\label{fig:coh}
\end{subfigure}
\caption{Important design pattern and best practices in object oriented software engineering}
\label{fig:patterns}
\end{figure}
\footnotetext[1]{\url{https://en.wikipedia.org/wiki/Model-view-controller}}
\footnotetext{\url{http://stackoverflow.com/questions/14000762/what-does-low-in-coupling-and-high-in-cohesion-mean}}

%%http://www.xyzws.com/scjp/SGS11/5/2
%Loose coupling makes it possible to:
%\begin{itemize}
%	\item Understand one class without reading others
%	\item Change one class without affecting others
%	\item Thus: improves maintainability
%\end{itemize}
%
%High cohesion makes it easier to:
%\begin{itemize}
%	\item Understand what a class or method does
%	\item Use descriptive names
%	\item Reuse classes or methods
%\end{itemize}

The improvements make it easier to reuse and extend the code in other projects. Thus, an early prototype of our implementation already served as base for concurrent interdisciplinary projects \cite{fischer2016idp,feil2016idp}. These described some details of our implementation and its benefits over previous approaches. Here, we want to describe the overall concept and all improvements made in a unified manner to serve as a good starting point for future project. The chapter is organized into sections according to the MVC principle.

\subsection{Model}
%\item[Model] A major refactoring of the basic Graph class with the extension to arbitrary resources, easier algorithm state handling and new upload/download functionalities.
The graph Model of the previous work was not very clean and thus substantially refactored and simplified while new features were added. It contained code concerning the naming, colouring and layout of nodes and edges and methods to draw them on Canvas and to detect clicks using coordinate comparisons. However, the Model should be oblivious to the actual graph drawing and interactions, since these belong to the View or the Controller. Moreover, the previous graph Model only allowed for a single scalar weight to be defined on edges. We extended it so that an arbitrary number of resources can be defined on both the edges and the nodes. This was especially needed for the SPPTW. Furthermore we add an associative array to nodes and edges to store the changing algorithm state, easing the replay functionality.

The new Graph class, composed by its subclasses GraphNode and GraphEdge, achieves high cohesion as can be seen in the UML diagram \refFigure{fig:model}. The static serialization and deserialization methods \underline{parse} and \underline{stringify} were extended to support arbitrary resource vectors. In previous work, the serialization capabilities were unaccessible to the end user. We provide a link to download a graph in its textual representation, which is backwards compatible to the previous work. Additionally, a user can now locally upload a previously saved graph right from the browser using HTML5's FileReader capabilities. The previous raw ajax calls to load a saved sample graph from a server are now nicely wrapped in d3.text calls.

The loading of a graph, either from a local file or a remote server, is an asynchronous operation. According to \textit{MVC} \refFigure{fig:mvc}, the Model should update the View after any modifications to it, e.g. when another sample graph was selected or uploaded. We achieve \textit{low coupling} \refFigure{fig:coh} between the different components through the use of a static callback function registration method \underline{addChangeListener} \refFigure{fig:model}. All functions (of the View) that have been registered will be called after the graph has been loaded asynchronically without errors. To synchronize the current graph between GraphEditor and Algorithm, we employ a singleton pattern using the static Graph \underline{instance}.


\renewcommand{\umldrawcolor}{black}

\colorlet{lightyellow}{yellow!20} %default color
\renewcommand{\umlfillcolor}{lightyellow}

\begin{figure}
\centering
\begin{tikzpicture}
  \begin{class}[text width=7cm]{Graph}{0,0}
    \attribute{\underline{instance} : Graph}
    %\attribute{\underline{onLoadedCbFp} : [function]}
    \operation{getNodes() : [GraphNode]}
    \operation{getEdges() : [GraphEdge]}
    \operation{\underline{stringify(graph : Graph)} : String}
    \operation{\underline{parse(text : String)} : Graph}
    \operation{\underline{addChangeListener(callbackFp : function)}}
    %\operation{\underline{loadInstance(fileurl : String)}}
    %\operation{\underline{handleFileSelect(filename : String)}}
  \end{class}
  
  \begin{class}[text width=5.5cm]{GraphNode}{-5,-5}
    \attribute{resources : []}
    \attribute{state : \{\}}
    \attribute{x : number}
    \attribute{y : number}
    \operation{getInEdges() : [GraphEdge]}
    \operation{getOutEdges() : [GraphEdge]}
  \end{class}
  
  \begin{class}[text width=5.5cm]{GraphEdge}{4,-5}
    \attribute{resources : []}
    \attribute{state : \{\}}

    \operation{getStartNode() : GraphNode}
    \operation{getEndNode() : GraphNode}
  \end{class}
  
  \begin{class}[text width=3cm]{ResidualEdge}{1,-10}
  \end{class}
  
  \begin{class}[text width=2cm]{Label}{6,-10}
  \end{class}
  
  \composition{Graph}{nodes}{*}{GraphNode}
  \composition{Graph}{edges}{*}{GraphEdge}
  \association{GraphNode}{start,end}{1}{GraphEdge}{*}{in,out}
  
  \unidirectionalAssociation{GraphNode}{eligible}{*}{ResidualEdge}
  \association{GraphEdge}{}{1}{ResidualEdge}{1..2}{}
  \association{Label}{resident}{*}{GraphNode}{resident}{1}
  \unidirectionalAssociation{Label}{path}{*}{GraphEdge}

\end{tikzpicture}
\caption{UML class diagram for the Model. From a high-level perspective, we model a Graph as a composition of nodes and edges with associations between these two entities reflecting the network structure: Each GraphEdge has a start and an end node, while each GraphNode has an arbitrary number of incoming and outgoing edges. Arrays for resources denoted by [] and associate arrays for state variables denoted by \{\} are attributes of both nodes and edges. Static attributes and method are \underline{underlined}. ResidualEdge and Label are two concepts that we needed for the implementation of our Algorithms. These are primarily associated with GraphEdge, either 1:1 or 2:1 for the first or 1:n for the latter. For performance reason, we also established associations with GraphNode. A GraphNode can be queried for all its current outgoing eligible ResidualEdges, which is needed for applying a push operation. Label and GraphNode are associated bidirectionally: a Label needs to know its resident vertex so it can check path extensions easily for feasibility using the time-window of the vertex, while a GraphNode can be queried for all the Labels ending in it so we can apply dominance rules to them.}
\label{fig:model}
\end{figure}



\subsection{View}
%\item[View] A complete rewrite of the abstract GraphDrawer class for network visualization using D3.js and SVG instead of Canvas with the possibility to download it in vector format at any time. A Logger utility which allows to log algorithm execution messages with up to 3 indentation levels.
 A complete rewrite of the graph visualization code using D3.js and SVG instead of Canvas. This is the GraphDrawer class, which should be used as a base class. Customization is easily possible by overwriting methods that will be called from inside of D3.js data join. Any visualization can be saved to disk in png or svg format, for which styles and marker definitions are automatically inlined. A Logger utility which allows to log algorithm execution messages with up to 3 indentation levels. This is very useful for development, but also for the final algorithm so people can trace the algorithm execution.


\colorlet{lightgreen}{Akzent-Gruen!50}%tumblue3!40!lightyellow} %default color
%accentuating green} %SpringGreen}

\begin{figure}
\centering
\hspace*{-1.5cm}%
\begin{tikzpicture}
  \renewcommand{\umlfillcolor}{tumblue4} %accentuating light blue}

  \begin{abstractclass}[text width=8cm]{GraphDrawer}{-3,0}
    \attribute{svg : <svg>}
    \operation{onNodesEntered(selection : [])}
    \operation{onNodesUpdated(selection : [])}
    \operation{onEdgesEntered(selection : [])}
    \operation{onEdgesUpdated(selection : [])}
    \operation{edgeText(d : GraphEdge) : String}
    \operation{nodeText(d : GraphNode) : String}
    \operation{nodeLabel(d : GraphNode) : String}
  \end{abstractclass}

  
  \begin{class}[text width=2.8cm]{LabelDrawer}{-4.9,-6}
  \end{class}
 
  \begin{class}[text width=5cm]{ResidualGraphDrawer}{3.5,-6}
  	\inherit{GraphDrawer}
  \end{class}
  

  \begin{class}[text width=2cm]{Logger}{-1,-6}
  \end{class}
  
  \renewcommand{\umlfillcolor}{lightgreen}
  
  \begin{class}[text width=3cm]{GraphEditor}{-8.5,-8}
    	\inherit{GraphDrawer}
  \end{class}
  
  \begin{class}[text width=5cm]{LabelSettingAlgorithm}{-3,-8}
  	\inherit{GraphDrawer}
  \end{class}

  \begin{class}[text width=5cm]{PushRelabelAlgorithm}{3,-8}
  	\inherit{GraphDrawer}
  \end{class}
  
  \begin{abstractclass}[text width=2.5cm]{Tab}{-3,-11}
  	\operation{init()}
  	\operation{activate()}
  	\operation{deactivate()}
  \end{abstractclass}
  
  \begin{class}[text width=3.5cm]{GraphEditorTab}{-7.5,-10}
    \inherit{Tab}
  	\operation{setGraphHandler()}
  \end{class}
  
  \begin{class}[text width=3.5cm]{AlgorithmTab}{2,-10}
    \inherit{Tab}
  	\operation{startFastForward()}
  	\operation{stopFastForward()}
  \end{class}
  
  \aggregation{LabelSettingAlgorithm}{}{}{LabelDrawer}
  \aggregation{PushRelabelAlgorithm}{}{}{ResidualGraphDrawer}
  
  
  \unidirectionalAssociation{AlgorithmTab}{}{}{Logger}
  \unidirectionalAssociation{LabelSettingAlgorithm}{}{}{AlgorithmTab}
  \unidirectionalAssociation{PushRelabelAlgorithm}{}{}{AlgorithmTab}
  \unidirectionalAssociation{GraphEditor}{}{}{GraphEditorTab}


\end{tikzpicture}
\caption{UML class diagram for View (blue) and Controller (green). The multiplicities are all 1:1 and thus not drawn. The abstract base class GraphDrawer of the View forms the basis for all graph-based visualizations. The Logger and the secondary visualization layers LabelDrawer and ResidualGraphDrawer are part of the View, but only the latter one displays a graph (with the possibility to change the axes) and thus extends the GraphDrawer. The abstract base class Tab of the Controller is extended to form a GraphEditorTab and an AlgorithmTab. Finally, the actual GraphEditor and the two implemented Algorithms are associated with a Tab while inheriting from the GraphDrawer. Each Algorithm has a secondary visualization layer, we model this relationship with an aggregation.}
\end{figure}


\subsection{Controller}
%\item[Controller] A new GraphEditor with support for modifying graphs with an arbitrary number of resources on nodes and edges easily. A small refactoring improved future code reusability and simplified the reverse functionality and the synchronization between algorithm state and pseudocode lines.
	A new way to save stateful data of the graph using JSON.stringify, which makes implementing the reverse functionality much easier. A new way to synchronize between the algorithm state (in the sense of a finite state machine), pseudocode lines, and their description using d3.



\section{Installation}\label{sec:installation}
