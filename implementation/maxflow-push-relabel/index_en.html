<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="This applet demonstrates the Goldberg Tarjan Push Relabel algorithm to find a maximum flow" />
    <meta name="keywords" content="Goldberg, Tarjan, maximum flow, algorithm, TUM, Technische Universität München, applet">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Adrian Haarbach">

<!--     the whole page layout style -->
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />

    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
 <!--   <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css"> -->

 <!--     MathJax, used in the more tab in pseudocode -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>

<!-- LOCAL -->

    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <link type="text/css" href="../library/css/mmenu/jquery.mmenu.all.css" rel="stylesheet" />
    <script type="text/javascript" src="../library/js/mmenu/jquery.mmenu.min.all.js"></script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="../library/js/d3/d3.js"></script>

<!-- CDN 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <link type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/css/jquery.mmenu.all.min.css" rel="stylesheet" />
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jQuery.mmenu/5.3.4/js/jquery.mmenu.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
-->
<!--     Adrians d3 related library code -->
    <script src="../library-d3-svg/js/Graph.js"></script>
    <script src="../library-d3-svg/js/GraphDrawer.js"></script>
    <script src="../library-d3-svg/js/GraphEditor.js"></script>
    <script src="../library-d3-svg/js/Logger.js"></script>
    <script src="../library-d3-svg/js/Tab.js"></script>
    <script src="../library-d3-svg/js/AlgorithmTab.js"></script>
    <script src="../library-d3-svg/js/GraphEditorTab.js"></script>
    <script src="../library-d3-svg/js/siteAnimation.js"></script>

    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/graph-style.css" />
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/style.css" />

<!--     Files used only for this applet -->
    <script src="js/ResidualEdge.js" type="text/javascript"></script>
    <script src="js/GoldbergTarjanPushRelabelAlgorithm.js" type="text/javascript"></script>
    <script src="js/HeightfunctionDrawer.js" type="text/javascript"></script>

    <title>Goldberg Tarjan Push Relabel Algorithm</title>
</head>

<!-- svg defs -->
<body>
<!--   <marker id="arrowhead" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto" stroke="red">
    <path d="M 0,0 V 4 L6,2 Z"></path>
  </marker>
   <marker id="arrowhead" refX="5" refY="0" markerWidth="4" markerHeight="4" viewBox="0 -5 10 10" orient="auto">
    <path d="M0,-5L10,0L0,5"></path>
  </marker> -->
  
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xlink="http://www.w3.org/1999/xlink">
  <defs>
    <marker id="arrowhead2" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>

     <marker id="arrowhead2-red" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="red">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>

     <marker id="arrowhead2-green" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto" markerUnits="userSpaceOnUse" fill="green">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>

     <marker id="arrowhead3" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto-start-reverse" markerUnits="userSpaceOnUse">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>

     <marker id="arrowhead3-red" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto-start-reverse" markerUnits="userSpaceOnUse" fill="red">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>

     <marker id="arrowhead3-green" refX="24" refY="4" markerWidth="24" markerHeight="8" orient="auto-start-reverse" markerUnits="userSpaceOnUse" fill="green">
      <path d="M 0,0 V 8 L12,4 Z"></path>
    </marker>
  </defs>
</svg>

    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Please activate Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                        This website needs Javascript in order to be displayed properly.
                    </li>
                    <li>
                        Javascript is currently deactivated in your browser. A manual for the activation of Javascript can be found <a href="http://www.enable-javascript.com/">here</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(function() {
            initializeSiteLayout(GoldbergTarjanPushRelabelAlgorithm);
            $("#year").html(new Date().getFullYear());
        });
        $(document).ready(function() {
            $("#menu").mmenu({
               "navbar": {
                  "title": "Übersicht"
               },
               "offCanvas": {
                  "zposition": "front"
               },
               "counters": true,
               "slidingSubmenus": true,
               "classes": "mm-light",
            });
         });
    </script>
    <a id="menu_link" href="#menu"></a>
    <nav id="menu">
        <ul>
            <li>
                <a style="white-space:pre-line" href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmen">
                <img src="../library/img/logo_ohne.png" alt="Übersichtsseite Graphalgorithmen">
                Übersichtsseite Graphalgorithmen</a>
            </li>
            <li><span>Kürzeste-Wege - Algorithmen</span>
                <ul>
                   <li><a href="../spp-dijkstra/index_de.html">Dijkstra - Algorithmus</a></li>
                   <li><a href="../spp-a-star/index_de.html">A* - Algorithmus</a></li>
                   <li><a href="../spp-bellman-ford/index_de.html">Bellman-Ford - Algorithmus</a></li>
                   <li><a href="../spp-floyd-warshall/index_de.html">Floyd-Warshall - Algorithmus</a></li>
                </ul>
            </li>
            <li><span>Spannbaum - Algorithmen</span>
                <ul>
                   <li><a href="../mst-prim/index_de.html">Algorithmus von Prim</a></li>
                   <li><a href="../mst-kruskal/index_de.html">Algorithmus von Kruskal</a></li>
                </ul>
            </li>
            <li><span>Matching - Algorithmen</span>
                <ul>
                   <li><a href="../matchings-hopcroft-karp/index_de.html">Algorithmus von Hopcroft-Karp</a></li>
                   <li><a href="../matchings-hungarian-method/index_de.html">Ungarische Methode</a></li>
                </ul>
            </li>
            <li><span>Eulerwege und Briefträgerproblem</span>
                <ul>
                   <li class="Selected"><a href="../hierholzer/index_de.html">Algorithmus von Hierholzer</a></li>
                   <li><a href="../directed-chinese-postman/index_de.html">Chinesisches Postboten-Problem</a></li>
                </ul>             
            </li>
        </ul>
    </nav>
    <div>
    <header>
        <img src="img/ahuja-small_progress.svg"></img>
        <span class="adrianheader">Goldberg Tarjan Push Relabel Algorithm</span>
        <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
    </header>
<!--     <svg height="0px" widht ="0px">
        <defs>
        <marker id="arrowhead2" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker>
        </defs>
    </svg> -->
    <div id="tabs">
        <ul>
            <li><a href="#tab_te"><span>Introduction</span></a></li>
            <li><a href="#tab_tg"><span>Create a graph</span></a></li>
            <li><a href="#tab_ta"><span>Run the algorithm</span></a></li>
            <li><a href="#tab_ti"><span>Description of the algorithm</span></a></li>
            <li><a href="#tab_tw"><span>More</span></a></li>
        </ul>

        <!-- TAB Einführung -->
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">

                <div id="te_div_beispiel1Container">
                  <img id="te_img_beispiel1" src="img/ahuja_final.svg">
                <p>The maximum s-t flow has a value of 6</p></div>
                
                <h1>The maximum flow problem</h1>
                <p>Suppose that we have a communication network, in which certain pairs of nodes are linked by connections; each connection has a limit to the rate at which data can be sent.
                Given two nodes on the network, what is the maximum rate at which one can send data to the other, assuming no other pair of nodes are attempting to communicate? <a href="https://lucatrevisan.wordpress.com/2011/02/04/cs261-lecture-9-maximum-flow/">(source)</a></p>
                <p>
                This is a typical instance of a maximum flow problem: given an underlying network, where the edge weights denote the maximum possible capacity per edge, one wants to find out how much can be transerred over the edges from the source node s to the target node t.</p>
                </p>
                <h2>This applet presents Goldberg Tarjan's Push Relabel algorithm with the FIFO selection rule which calculates the maximum s-t flow on a directed, weighted graph in \(O(|V|^3)\). This is much faster than the older Edmonds-Karp or Dinic's algorithm, which are based on the Ford-Fulkerson method.</h2>
                <div id ="te_div_Entscheidung">
                    <h2>What do you want to do first?</h2>
                    <button id="te_button_gotoDrawGraph">Test the algorithm!</button> <button id="te_button_gotoIdee">Read detailed description of the algorithm</button>
                </div>
                <p></p>
                <br style="clear: both;" />
            </div>
        </div>

        <!-- TAB Graph Erstellen -->
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer">
                      <svg class="graphCanvas" id="tg_canvas_graph" width="700" height="500"></svg>
                      <a class="svgDownloader" download="graph-editor.svg" href="data:text/plain,test">maxflow-graph-editor.svg</a>
                    </div>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>edge with capacity cap</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Which graph do you want to execute the algorithm on?</h2>
                    <h3>Start with an example graphs:</h3>
                    <label for="graphSelector">Select </label>
                    <select name="graphSelector" id="tg_select_GraphSelector">
                        <option selected = true label="Ahuja p.227">ahuja</option>
                        <option label="Ahuja small">ahuja-small</option>
                        <option label="Corman p.726">corman</option>
                        <option label="Corman small">corman-small</option>
                        <option label="Corman rotated">corman-rotated</option>
                        <option label="Jungnickel p.214">jungnickel</option>
                        <option label="Wikipedia">wiki</option>
                        <option label="Algoprak Push-Relabel example">algoprak-push-relabel-example</option>

                        <option label="European capitals (double edges)">europe</option>

                        <option label="graph 2">graph2</option>
                        <option label="graph 5">graph5</option>
                    </select>


                    <h3>Modify it to your desire:<br></h3>
                    <div id="tg_div_statusErklaerung">
                    <ul>
                        <li>To create a node, make a double-click in the drawing area.</li>
                        <li>To create an edge, first click on the output node and then click on the destination node.</li>
                        <li>The edge weight can be changed by double clicking on the edge.</li>
                        <li>Right-clicking deletes edges and nodes.</li>
                    </ul>
                    </div>
                    
                    <h3>Download the modified graph:</h3>
                    
                    <a id="fileDownloader" download="graph.txt" href="data:text/plain,test">Download</a>
                    
                    <h3>Upload an existing graph:</h3>
                    <input type="file" id="fileUploader" accept=".txt"/></input> <!--name="files[]" accept="text/*"-->
                    <div id="ta_div_parseError" title="Error reading graph from file">
<!--                         <h2>Error code:</h2> -->
                        A
                        <h2 style="color:red" id="ta_div_parseErrorText"></h2>
                        occured when reading from file:
                        <h3 id="ta_div_parseErrorFilename"></h3>
                        the contents:
                        <pre id="ta_div_parseErrorDescription"></pre>
                    </div>

                    <h3>What next?</h3>
                   <p><button id="tg_button_gotoAlgorithmTab">Ready &ndash; Run the Algorithm!</button></p>


                </div>
            </div>
        </div>

        <!-- TAB Algorithmus ausführen -->
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                   <table>
                    <tr>
                      <td class="svgContainer">
                        <svg class="graphCanvas" id="ta_canvas_graph" width="350" height="500"></svg>
                        <a class="svgDownloader" download="maxflow-graph-algorithm-graph.svg" href="data:text/plain,test">maxflow-graph-algorithm-graph.svg</a>
                      </td>
                      <td class="svgContainer">
                        <svg class="graphCanvas" id="ta_canvas_graph2" width="350" height="500"></svg>
                        <select id="heightFunctionXAxis">
                            <option value="graph">y/x (graph)</option>
                            <option value="excess">height/excess</option>
                            <option value="id">height/id</option>
                        </select><br>
                        <a class="svgDownloader" download="maxflow-graph-algorithm-height.svg" href="data:text/plain,test">maxflow-graph-algorithm-height.svg</a>
                      </td>
                    </tr>
                    </table>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-e-h.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>node with excess flow and height function</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-current.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>current node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/nodes-active.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>active nodes</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>edge with flow &le; cap</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/st-flow.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>s-t flow</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Algorithm status</h2>
                    <div id="ta_div_abspielbuttons"> <!--class="ui-widget-header ui-corner-all"-->
                        <input  id="ta_button_rewind" type="checkbox"><label for="ta_button_rewind" id="ta_button_text_rewind">rewind</label>
                        
                        <button id="ta_button_Zurueck">prev</button>
                        
                        <button id="ta_button_1Schritt">next</button>
                        
                        <input  id="ta_button_vorspulen" type="checkbox"><label for="ta_button_vorspulen" id="ta_button_text_fastforward">fast forward</label>

                        <input type="number" id="ta_vorspulen_speed" min="2" max="500" value=5>ms

                        <span id="ta_button_text_pause" style="display:none">pause</span>
                    </div>
<!--                     <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                            <li><a href="#ta_div_statusLogger">Log</a></li>
                        </ul> -->
                        <div id="ta_div_statusErklaerung">
                            <div>
                                <h3>First choose a source node</h3>
                                <p>Click on a node to select it as the source/starting node s</p>
                            </div>
                            <div>
                                <h3>Then choose a target node</h3>
                                <p>Click on a node to select it as the target/sink node t</p>
                            </div>
                            <div>
                                <h3>Goldberg-Tarjan Push-Relabel maximum flow algorithm</h3>
                                <p>Now the algorithm can begin. Click on <strong>next</strong> to start it</p>
                            </div>
                            <div>
                                <h3>Initializing the preflow</h3>
                                <p>Set f(e) = c(e) for all edges emanating s and set f(e) = 0 for all other edges. Add all nodes v &ne; t having (s,v) &isin; E to the queue Q of active nodes.</p>
                            </div>
                            <div>
                                <h3>Initializing the height function</h3>
                                <p>For each node v &ne; s set h(v) to the shortest directed path from v to t in the network G where the length of a path is the number of edges of the path. (In particular, set h(t) = 0).

                                This can be done in time O(|V| + |E|) by a breadth first search starting at t and using all edges in the opposite direction. The source s isn’t reached by this BFS.

                                We initialize h(s) by setting h(s) = |V|.</p>
                            </div>
                            <div>
                                <h3>Main loop</h3>
                                <p>As long as the queue Q containing the active nodes isn’t empty pop the first node v from the front of Q and apply a push/relabel-operation to v.</p>
                            </div>
                            <div>
                                <h3>Check for admissible push operations</h3>
                                <p>While e(v) > 0 and the residual network G'=(V,E') contains an edge that is legal with respect to the current height function ( i.e., there is an edge e' = (v, w) having h(v) = h(w) +  1 ) apply a push</p>
                            </div>
<!--                             The residual network G'=(V,E') around a node v can be constructed on the fly. For this, we have to consider both the incoming (u,v) as well as the outgoing (v,w) edges in E. -->
                            <div>
                                <h3>Push</h3>
                                <p>Push &delta; = min{e(v), c'(e')} amount of flow from v to w.</p>

                                <p>More precisely, if e' &in; E' is a forward edge with respect to an edge e of G, increase the preflow f(e) of e by &delta;, and if e' is a backward edge, then decrease the preflow f(e) of e by &delta;.</p>

                                <p>By doing so, e(v) is decreased by &delta;, and e(w) is increased by &delta;. If w &ne; s,t, and if w wasn't active before, w becomes active, and is added at the end of the queue Q containing the active nodes.</p>
                            </div>
                            <div>
                                <h3>Check for an admissible relabel operation</h3>
                                <p>If v has still excess, i.e., e(v) > 0, and if there is no legal edge emanating from v in the residual network, then apply a relabel operation. </p><!-- as described in the following, and add v at the end of the queue after that. -->
                            </div>
                            <div>
                                <h3>Relabel</h3>
                                <p>Increase the height h(v) of v to the value</p>
                                <p>min{ h(w)+1 | (v,w) is edge of the residual network G'}</p>
                                <p>add v at the end of the queue Q after that.</p>
                            </div>
                            <div>
                                <h3>Finished</h3>
                                <p>The algorithm terminated with a maximum flow value of:</p>
                                <p id="finalflow" style="color:green"></p>
                            </div>
                        </div>
                        <div id="loggerLastEntry"></div>

<!--var STATUS_SELECTSOURCE = id++;
    var STATUS_SELECTTARGET = id++;
    var STATUS_START = id++;
    var STATUS_INITPREFLOW = id++;
    var STATUS_INITDISTANCEFUNCTION = id++;
    var STATUS_MAINLOOP = id++;
    var STATUS_ADMISSIBLEPUSH = id++;
    var STATUS_PUSH = id++;
    var STATUS_ADMISSIBLERELABEL = id++;
    var STATUS_RELABEL = id++;
    var STATUS_FINISHED = id; -->
<div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
<div><p>s &larr; pick(v)</p></div>
<div><p>t &larr; pick(v)</p></div>
<div><p>BEGIN</p></div>
<div><p>(* Initializing the preflow *)</p>
   <p> FORALL e=(u,w) &isin; E</p>
   <p>    IF u == s THEN f(e) &larr; c(e)</p>
   <p>    ELSE f(e) &larr; 0</p>
   <p>    IF u == s AND w &ne; t THEN Q.add(w)</p></div>
<div><p>(* Initializing the height function *)</p>
   <p> h(s) = |V|</p>
   <p> FORALL v &isin; V\{s}</p>
   <p>    h(v) &larr; number of segments on directed path to t</p></div>
<div><p>(* Main Loop *)</p>
   <p> WHILE Q &ne; &empty;</p>
   <p>    v &larr; Q.pop()</p></div>
<div><p>    WHILE e(v) > 0 </p>
   <p>    AND &exist; e'=(v,w) &isin; E' with h(v) == h(w) + 1</p></div>
<div><p>       (* PUSH *)</p>
   <p>       push min{e(v),c'(e')} flow from v to w</p>
   <p>       IF w != s,t AND w &notin; Q THEN Q.add(w)</p></div>
<div><p>     IF e(v) > 0 AND &#8708; e'=(v,w) &isin; E'; h(v) == h(w) + 1</p></div>
<div><p>       (* RELABEL *)</p>
   <p>       h(v) &larr; min{h(w)+1 | (v,w) &isin; E'</p>
   <p>       Q.add(v)</p></div>
<div><p>END</p></div>
</div>
                <!--    </div> -->
                            <h3>Variable status</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>v</span></th>
                                    <th class="algoInfoTH"><span>Q</span></th>
                                    <th class="algoInfoTH"><span>e'</span></th>
                                    <th class="algoInfoTH"><span>c'</span></th>
                                </tr>
                                <tr>
                                    <td id="ta_td_v" class="algoInfoTD">-</td>
                                    <td id="ta_td_queue" class="algoInfoTD">&#8709;</td>
                                    <td id="ta_td_e_dash" class="algoInfoTD">-</td>
                                    <td id="ta_td_c_dash" class="algoInfoTD">-</td>
                                </tr>
                            </table>
                       <div id="ta_div_statusLogger">
                            <h3>Log of algorithm execution</h3>
                            <div id="logger"></div>
                        </div>
                </div>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>

        <!-- TAB Beschreibung des Algorithmus -->
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">
                <div class="BeispielbildContainer">
                    <img src="img/ahuja_init.svg"/>
                    <p>Graph \(G=(V,E)\) with capacities \(c(e)\geq0 \forall e\in E\)</p>
                </div>
                <h1>Maximum Flows</h1>
                <p>In many applications one wants to know how much flow of a certain resource can simultaneously be transferred over a network from a to b.
                Depending on the context, flow can mean different things: The amount of water in a water pipe system in your city or the bandwidth of a computer network.
                However, the links in the network on paths from a to b can only handle flow up to their maximum capacity. One now seeks an assignemt of flow values to edges that fulfills all the capacity constraints of the edges and the flow conservation property on all the inner nodes, meaning we don't want leaks in our pipe system.
                </p>
                <p><strong>In general we speak of a flow</strong>.
                Therefore one assigns a flow value to each edge in our network, the graph</p>
                <p>The Push-Relabel Algorithm of Goldberg and Tarjan computes the maximum s-t flow on a graph</p>
               
               <h2>Flow in graphs</h2>
               <p>digraph \(G = (V, E)\)</p>
                <div>A flow network \( N=(G,c,s,t) \)<br>
                    <ul>
                        <li>capacity \(\forall e \in E: c(e) \geq 0 \)</li>
                        <li>source and sink \( s,t \in V \)</li>
                    </ul>
                </div>

                <div>A flow on N: \( f : E \rightarrow \mathbb{R}_o^+ \)
                    <ol>
                        <li>feasability / capacity constraints: \( \forall e \in E : f(e) \leq c(e) \) </li>
                        <li>flow conservation: \( \forall u \in V \setminus \{s,t\} : \sum_{v \in V} f(u,v) = \sum_{v \in V} f(v,u)\)</li>
                    </ol>
                </div>

                <li>flow conservation:
				\( \forall u \in V \setminus\{s,t\}: e(u) = 0\)</li>


               <h2>The residual network</h2>
                <div class="BeispielbildContainer">
                    <img width="200px" src="img/residual-network.png"/>
                    <p>create the residual network</p>
                </div>
For a (not necessarily feasible) flow \(f : E \rightarrow \mathbb{R}\) in \(G = (V,E) \) we can construct the so called residual network \(G' = (V, E') \):
Create the graph G0 from G by copying all nodes of G and adding edges to G0 under the following rules.


               <h1>Idea of the algorithm</h1>

               <h2>preflow</h2>


			 preflow:
				\( \forall u \in V \setminus\{s,t\}: e(u) \geq 0\)

               <h2>height function</h2>
               height \( h(u), u \in V \)

               <h2>excess</h2>
               <li>exess  \( e(u) = \sum_{v \in V} f(u,v) - \sum_{v \in V} f(v,u), u \in V \)</li>

               </div>
        </div>

       
        <!-- TAB Weiteres -->
<div id="tab_tw" style="display: none;">
<div id="tw_Accordion">
<h3>What is the pseudocode of the algorithm?</h3>
<div>
<pre><code>
Input:  a directed graph G=(V,E) with source node s, target node t.
        edge capacities c(e)>=0 for all edges
Output: A feasible maximum s-t flow f(e) satisfying:
        capacity constraints : 0<=f(e)<=c(e) for all edges
        flow conservation : f(u,v) == f(v,u) for all nodes except s,t
        The flow value of f(e) is maximized along all feasible flows
</code></pre><!-- , which fulfills the capacity constraints f(e) leq c(e) for all edges, flow conservation at all inner nodes and maximises the flow value over all feasible flows. -->
<hr>
<pre><code id=tw_div_statusPseudocode>
</code></pre>
</div>
<h3>How fast is the algorithm?</h3>
<div>

The running time of the generic Goldberg and Tarjan's push relabel algorithm (1988) is \( O(|V|^2|E|) \).
<p>
This is the same asymptotical performance as that of Dinic's algorithm (1970), itself a tuned version of Edmonds–Karp algorithm \( O(|V||E|^2) \).
These two classical maximum flow algorithms, emerging from the Ford-Fulkerson method (1956) are based on augmenting s-t paths and preserve the flow conservation property at inner nodes (e.g no excess) even during the course of the algorithm.
</p><p>
So why did we even need another method if it is not asymptotically faster than the existing ones and adds additional complexity?
It turns out that we can further tune the generic algorithm by specifiing the order in which we choose the active nodes which we apply push and relabel operations to.
</p><p>
In particular, the variant implemented in this applet chooses the FIFO rule when selecting active nodes from the queue Q, which has a running time of  \( O(|V|^3) \), which is better than the previous bound, especially on dense graphs (it is actually independend on the number of edges).
</p><p>
Certain modifications of the generic algorithm  are among the fastest algorithms known today to solve maximum flow problems. For a comparison, please refer to this <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem#Solutions">table</a>.
</p>
</div>
<h3>When does the algorithm terminate?</h3>
<div>
The algorithm terminates when the queue containing the active nodes is empty. When that happens, the preflow is also a 
feasible maximum flow since the residual network doesn’t contain augmenting pathes from s to t (since d(s) = |V|). 
</div>

<h3>Goldberg and Tarjan about the History of Efficient Maximum Flow Algorithms algorithms (video)</h3>
<div>
<iframe src="https://player.vimeo.com/video/100774435" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
<p><a href="https://vimeo.com/100774435">Efficient Maximum Flow Algorithms</a> from <a href="https://vimeo.com/user4730653">CACM</a> on <a href="https://vimeo.com">Vimeo</a>.</p>
source: [GT2014]
</div>


<h3>References</h3>
<div>
<h4>Literature</h4>
<dl>

<dt>[GT88] (primary)</dt>
<dd>Andrew V. Goldberg und Robert E. Tarjan. „A new approach to the maximum-flow problem“. 
In: J. Assoc. Comput. Mach. 35.4 (1988), S. 921–940. issn: 0004-5411. doi: 10.1145/48014.61051. 
url: <a href="http://dx.doi.org/10.1145/48014.61051">http://dx.doi.org/10.1145/48014.61051</a>.
</dd>
<br>

<dt>[GT2014]</dt>
<dd>Andrew V. Goldberg and Robert E. Tarjan. 2014. Efficient maximum flow algorithms. Commun. ACM 57, 8 (August 2014), 82-89. 
DOI=<a href="http://dx.doi.org/10.1145/2628036">http://dx.doi.org/10.1145/2628036</a>.
</dd>
<br>

<dt>[AMO93]</dt>
<dd>Ravindra K. Ahuja, Thomas L. Magnanti und James B. Orlin. Network flows. Theory, algorithms, and applications. 
Prentice Hall, Inc., Englewood Cliffs, NJ, 1993, S. xvi+846. isbn: 0-13-617549-X.</dd>
<dd>
<ul>
7: MAXIMUM FLOWS: POLYNOMIAL ALGORITHM
<ul>
  <li>7.6: Generic Preflow-Push Algorithm </li>
  <li>7.7: FIFO Preflow-Push Algorithm</li>
  <li>7.8: Highest-Label Preflow-Push Algorithm</li>
</ul>
</ul>
</dd>


<dt>[Jun13]</dt>
<dd>Dieter Jungnickel. Graphs, networks and algorithms. Fourth. Bd. 5. Algorithms and Com- putation in Mathematics. 
Springer, Heidelberg, 2013, S. xx+675. isbn: 978-3-642-32277-8; 978-3-642-32278-5. doi: 10.1007/978-3-642-32278-5. 
url: <a href="http://dx.doi.org/10.1007/978-3-642-32278-5">http://dx.doi.org/10.1007/978-3-642-32278-5</a>.</dd>
<dd>
<ul>
6: Flows
<ul>
  <li>6.6: The Algorithm of Goldberg and Tarjan </li>
</ul>
</ul>
</dd>


<dt>[Cor09]</dt>
<dd>Thomas H. Cormen. Introduction to algorithms. MIT press, 2009.</dd>
<dd>
<ul>
VI: Graph Algorithms
<ul>
  <li>26: Maximum Flow</li>
  <ul>
    <li>26.4: Push-relabel algorithms</li>
    <li>26.5: The relabel-to-front algorithm</li>
  </ul>
</ul>
</ul>
<dd>

</dl>

<h4>Web resources</h4>
                <ol>
<!--            <li>Goldberg, Andrew V., and Robert E. Tarjan. "A new approach to the maximum-flow problem." Journal of the ACM (JACM) 35.4 (1988): 921-940.</li>
                <li>Ahuja, Ravindra K., Thomas L. Magnanti, and James B. Orlin. "Network flows. 1993." Pg 39: 193-196.</li>
                <li>Ahuja, Ravindra K., Thomas L. Magnanti, and James B. Orlin. Network flows. No. MIT-WP-2059-88. ALFRED P SLOAN SCHOOL OF MANAGEMENT CAMBRIDGE MA, 1988.</li>
                <li>Jungnickel, Dieter. Graphs, networks and algorithms. Heidelberg: Springer, 2008.</li>
                <li>Cormen, Thomas H. Introduction to algorithms. MIT press, 2009.</li> -->
                <li><a href="http://wwwmayr.in.tum.de/lehre/2013WS/algoprak/uebung/tutorial6.english.pdf">Mayr algoprak tutorial</a></li>
                <li><a href="http://people.mpi-inf.mpg.de/~mehlhorn/DatAlg/Maxflow.pdf">Mehlhorn Maxflow slides</a></li>
                <li><a href="https://people.orie.cornell.edu/dpw/orie633/LectureNotes/lecture5.pdf">Network flows lecture notes</a></li>
                <li>Boost
                <a href="http://www.boost.org/doc/libs/1_61_0/libs/graph/doc/graph_theory_review.html#sec:network-flow-algorithms">Network flows Intro</a>
                <a href="http://www.boost.org/doc/libs/1_61_0/libs/graph/doc/push_relabel_max_flow.html">push_relabel_max_flow</a>
                </li>
                <li>Wikipedia
                <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">Maximum flow problem</a>
                <a href="https://en.wikipedia.org/wiki/Push–relabel_maximum_flow_algorithm">Push-relabel maximum flow algorithm</a>
                </li>
                <li><a href="https://lucatrevisan.wordpress.com/2011/02/04/cs261-lecture-9-maximum-flow/">blog entry</a></li>
                <li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-section-1/">topcoder tutorial</a></li>
                </ol>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Project of Adrian Haarbach at Chair M9 of Technische Universität München. <span id="year">2015</span> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Terms of use</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">About Us</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Suggestions</a>
        </p>
    </footer>
</body>