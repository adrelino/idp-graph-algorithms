<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta charset="utf-8">
    <meta name="description" content="This applet demonstrates the Goldberg Tarjan Push Relabel algorithm to find a maximum flow" />
    <meta name="keywords" content="Goldberg, Tarjan, maximum flow, algorithm, TUM, Technische Universität München, applet">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="author" content="Adrian Haarbach">

<!--     the whole page layout style -->
    <link rel="stylesheet" type="text/css" href="../library/css/style.css" />

    <!-- jquery + jqueryui -->
    <script src="../library/js/jquery-1.9.1.min.js" type="text/javascript"></script>
    <script src="../library/js/jquery-ui-1.10.1.custom.min.js" type="text/javascript"></script>
    <link rel="stylesheet" type="text/css" href="../library/css/tum-theme2/jquery-ui-1.10.1.custom.min.css" />
<!--     <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js"></script>
    <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css"> -->

<!--     the menu  -->
    <link type="text/css" href="../library/css/mmenu/jquery.mmenu.all.css" rel="stylesheet" />
    <script type="text/javascript" src="../library/js/mmenu/jquery.mmenu.min.all.js"></script>

<!--     MathJax, used in the more tab in pseudocode -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            showMathMenu: false,
            showMathMenuMSIE: false
        });
    </script>
    <script type="text/javascript" src="../library/js/mathjax/MathJax.js?config=TeX-AMS-MML_SVG.js&locale=en"></script>


<!--     Adrians d3 related library code -->
    <script src="../library-d3-svg/js/d3/d3.js"></script>
    <script src="../library-d3-svg/js/Graph.js"></script>
    <script src="../library-d3-svg/js/GraphDrawer.js"></script>
    <script src="../library-d3-svg/js/GraphEditor.js"></script>
    <script src="../library-d3-svg/js/Logger.js"></script>
    <script src="../library-d3-svg/js/Tab.js"></script>
    <script src="../library-d3-svg/js/AlgorithmTab.js"></script>
    <script src="../library-d3-svg/js/GraphEditorTab.js"></script>
    <script src="../library-d3-svg/js/siteAnimation.js"></script>

    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/graph-style.css" />
    <link rel="stylesheet" type="text/css" href="../library-d3-svg/css/style.css" />

<!--     Files used only for this applet -->
    <script src="js/GoldbergTarjanPushRelabelAlgorithm.js" type="text/javascript"></script>

    <title>Goldberg Tarjan Push Relabel Algorithm</title>
</head>
<body>
    <noscript>
        <div class="ui-widget">
            <div class="ui-state-error ui-corner-all" style="padding: .7em;">
                <div class="ui-icon ui-icon-alert errorIcon"></div>
                <strong>Please activate Javascript!</strong>
                <ul style="margin: 0px;">
                    <li>
                        This website needs Javascript in order to be displayed properly.
                    </li>
                    <li>
                        Javascript is currently deactivated in your browser. A manual for the activation of Javascript can be found <a href="http://www.enable-javascript.com/">here</a>.
                    </li>
                </ul>
            </div>
        </div>
    </noscript>
    <script>
        $(function() {
            initializeSiteLayout(GoldbergTarjanPushRelabelAlgorithm);
            $("#year").html(new Date().getFullYear());
        });
        $(document).ready(function() {
            $("#menu").mmenu({
               "navbar": {
                  "title": "Übersicht"
               },
               "offCanvas": {
                  "zposition": "front"
               },
               "counters": true,
               "slidingSubmenus": true,
               "classes": "mm-light",
            });
         });
    </script>
    <a id="menu_link" href="#menu"></a>
    <nav id="menu">
        <ul>
            <li>
                <a style="white-space:pre-line" href="http://www-m9.ma.tum.de/Allgemeines/GraphAlgorithmen">
                <img src="../library/img/logo_ohne.png" alt="Übersichtsseite Graphalgorithmen">
                Übersichtsseite Graphalgorithmen</a>
            </li>
            <li><span>Kürzeste-Wege - Algorithmen</span>
                <ul>
                   <li><a href="../spp-dijkstra/index_de.html">Dijkstra - Algorithmus</a></li>
                   <li><a href="../spp-a-star/index_de.html">A* - Algorithmus</a></li>
                   <li><a href="../spp-bellman-ford/index_de.html">Bellman-Ford - Algorithmus</a></li>
                   <li><a href="../spp-floyd-warshall/index_de.html">Floyd-Warshall - Algorithmus</a></li>
                </ul>
            </li>
            <li><span>Spannbaum - Algorithmen</span>
                <ul>
                   <li><a href="../mst-prim/index_de.html">Algorithmus von Prim</a></li>
                   <li><a href="../mst-kruskal/index_de.html">Algorithmus von Kruskal</a></li>
                </ul>
            </li>
            <li><span>Matching - Algorithmen</span>
                <ul>
                   <li><a href="../matchings-hopcroft-karp/index_de.html">Algorithmus von Hopcroft-Karp</a></li>
                   <li><a href="../matchings-hungarian-method/index_de.html">Ungarische Methode</a></li>
                </ul>
            </li>
            <li><span>Eulerwege und Briefträgerproblem</span>
                <ul>
                   <li class="Selected"><a href="../hierholzer/index_de.html">Algorithmus von Hierholzer</a></li>
                   <li><a href="../directed-chinese-postman/index_de.html">Chinesisches Postboten-Problem</a></li>
                </ul>             
            </li>
        </ul>
    </nav>
    <div>
    <header>
        <img src="img/ahuja-small-progress.svg" alt="A maximum flow"></img>
        <span class="adrianheader">Goldberg Tarjan Push Relabel Algorithm</span>
        <img style="position:absolute; right:0px" src="../library/img/TUMLogo.png" alt="Technische Universität München">
    </header>
<!--     <svg height="0px" widht ="0px">
        <defs>
        <marker id="arrowhead2" refX="12" refY="2" markerWidth="12" markerHeight="4" orient="auto"><path d="M 0,0 V 4 L6,2 Z"></path></marker>
        </defs>
    </svg> -->
    <div id="tabs">
        <ul>
            <li><a href="#tab_te"><span>Introduction</span></a></li>
            <li><a href="#tab_tg"><span>Create a graph</span></a></li>
            <li><a href="#tab_ta"><span>Run the algorithm</span></a></li>
            <li><a href="#tab_ti"><span>Description of the algorithm</span></a></li>
            <li><a href="#tab_tw"><span>More</span></a></li>
        </ul>

        <!-- TAB Einführung -->
        <div id="tab_te">
            <div id="te_div_Einfuehrungstext">

                <div id="te_div_beispiel1Container">
                <div id="svgtest"></div>
                <img id="te_img_beispiel1" src="img/ahuja.svg" alt="ahuja">
<!--                 <object data="img/ahuja.svg" type="image/svg+xml" width="300px"> -->
<!--                 type="image/svg+xml"-->

<!--                 <svg> 
                    <image xlink:href="img/ahuja.svg" src="svg.png">
                </svg> -->


                <p>The maximum s-t flow has a value of 6</p></div>
<!--                 <div id="te_div_beispiel1Container"><img id="te_img_beispiel1" src="https://i1.wp.com/cs.stanford.edu/people/trevisan/cs261-11/network1.png" alt="Flow problem in network routing capacity"><p>Flow problem in network routing capacity</p></div> -->
                
                <h1>The maximum flow problem</h1>
                <p>Suppose that we have a communication network, in which certain pairs of nodes are linked by connections; each connection has a limit to the rate at which data can be sent.
                Given two nodes on the network, what is the maximum rate at which one can send data to the other, assuming no other pair of nodes are attempting to communicate? <a href="https://lucatrevisan.wordpress.com/2011/02/04/cs261-lecture-9-maximum-flow/">(source)</a></p>
                
                <p>
                This is a typical instance of a maximum flow problem: given an underlying network, where the edge weights denote the maximum possible capacity per edge, one wants to find out how much can be transerred over the edges from the source node s to the target node t.</p>
                </p>
                <h2>This applet presents the generic Goldberg Tarjan's Push Relabel algorithm which calculates the maximum s-t flow on a directed, weighted graph in a fairly good runtime. More classical but slower algorithms are Ford-Fulkerson/Edmonds-Karp/Dinic algorithms</h2>
                <div id ="te_div_Entscheidung">
                    <h2>What do you want to do first?</h2>
                    <button id="te_button_gotoDrawGraph">Test the algorithm!</button> <button id="te_button_gotoIdee">Read detailed description of the algorithm</button>
                </div>
                <p></p>
                <br style="clear: both;" />
            </div>
        </div>

        <!-- TAB Graph Erstellen -->
        <div id="tab_tg">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer"><svg class="graphCanvas" id="tg_canvas_graph" width="700" height="500"></svg></div>
                    <a class="svgDownloader" download="graph-editor.svg" href="data:text/plain,test">SVG Download</a>
                    <div class="Legende" id="tg_div_Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>edge with capacity cap</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="tg_div_statusWindow" class="statusWindow">
                    <h2>Which graph do you want to execute the algorithm on?</h2>
                    <h3>Start with an example graphs:</h3>
                    <label for="graphSelector">Select </label>
                    <select name="graphSelector" id="tg_select_GraphSelector">
                        <option label="ahuja page 227">graph1</option>
                        <option label="graph 2">graph2</option>
                        <option label="European capitals (double edges)">graph3</option>
                        <option label="corman page 726">graph4</option>
                        <option label="graph 5">graph5</option>
                        <option label="from wikipedia">graph6</option>
                        <option label="jungnickel page 214">graph7</option>
                        <option label="corman rotated">corman2</option>
                    </select>


                    <h3>Modify it to your desire:<br></h3>
                    <div id="tg_div_statusErklaerung">
                    <ul>
                        <li>To create a node, make a double-click in the drawing area.</li>
                        <li>To create an edge, first click on the output node and then click on the destination node.</li>
                        <li>The edge weight can be changed by double clicking on the edge.</li>
                        <li>Right-clicking deletes edges and nodes.</li>
                    </ul>
                    </div>
                    
                    <h3>Download the modified graph:</h3>
                    
                    <a id="fileDownloader" download="graph.txt" href="data:text/plain,test">Download</a>
                    
                    <h3>Upload an existing graph:</h3>
                    <input type="file" id="fileUploader" accept=".txt"/></input> <!--name="files[]" accept="text/*"-->
                    <div id="ta_div_parseError" title="Error reading graph from file">
<!--                         <h2>Error code:</h2> -->
                        A
                        <h2 style="color:red" id="ta_div_parseErrorText"></h2>
                        occured when reading from file:
                        <h3 id="ta_div_parseErrorFilename"></h3>
                        the contents:
                        <pre id="ta_div_parseErrorDescription"></pre>
                    </div>

                    <h3>What next?</h3>
                   <p><button id="tg_button_gotoAlgorithmTab">Ready &ndash; Run the Algorithm!</button></p>


                </div>
            </div>
        </div>

        <!-- TAB Algorithmus ausführen -->
        <div id="tab_ta">
            <div>
                <div class="canvasWrapper">
                    <div class="svgContainer"><svg class="graphCanvas" id="ta_canvas_graph" width="700" height="500"></svg></div>
                    <a class="svgDownloader" download="graph-algorithm.svg" href="data:text/plain,test">SVG Download</a>
                    <div class="Legende">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                        <div class="LegendeText">
                            <table>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-e-h.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>node with exess flow and height function</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/node-current.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>current node</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/nodes-active.svg" alt="node" class="LegendeIcon"></td>
                                    <td><span>active nodes</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/edge-flow.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>edge with flow &le; cap</span></td>
                                </tr>
                                <tr>
                                    <td class="LegendeTabelle"><img src="img/st-flow.svg" alt="edge" class="LegendeIcon"></td>
                                    <td><span>s-t flow</span></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                    <div class="LegendeMinimized">
                        <h2 class="LegendeHeader"><button class="LegendeMin"></button> Legende</h2>
                    </div>
                </div>
                <div id="ta_div_statusWindow" class="statusWindow">
                    <h2 class="">Algorithm status</h2>
                    <div id="ta_div_abspielbuttons"> <!--class="ui-widget-header ui-corner-all"-->
                        <input  id="ta_button_rewind" type="checkbox"><label for="ta_button_rewind" id="ta_button_text_rewind">rewind</label>
                        
                        <button id="ta_button_Zurueck">prev</button>
                        
                        <button id="ta_button_1Schritt">next</button>
                        
                        <input  id="ta_button_vorspulen" type="checkbox"><label for="ta_button_vorspulen" id="ta_button_text_fastforward">fast forward</label>

                        <input type="number" id="ta_vorspulen_speed" min="2" max="500" value=5>ms

                        <span id="ta_button_text_pause" style="display:none">pause</span>
                    </div>
                    <div id="ta_div_statusTabs">
                         <ul>
                            <li><a href="#ta_div_statusErklaerung">Explanation</a></li>
                            <li><a href="#ta_div_statusPseudocode">Pseudocode</a></li>
                            <li><a href="#ta_div_statusLogger">Log</a></li>
                        </ul>
                        <div id="ta_div_statusErklaerung">
                            <div>
                                <h3>First choose a source node</h3>
                                <p>Click on a node to select it as the source/starting node s</p>
                            </div>
                            <div>
                                <h3>Then choose a target node</h3>
                                <p>Click on a node to select it as the target/sink node t</p>
                            </div>
                            <div>
                                <h3>Goldberg-Tarjan Push-Relabel maximum flow algorithm</h3>
                                <p>Now the algorithm can begin. Click on <strong>next</strong> to start it</p>
                            </div>
                            <div>
                                <h3>Initializing the preflow</h3>
                                <p>Set f(e) = c(e) for all edges emanating s and set f(e) = 0 for all other edges. Add all nodes v &ne; t having (s,v) &isin; E to the queue of active nodes.</p>
                            </div>
                            <div>
                                <h3>Initializing the distance function</h3>
                                <p>For each node v &ne; s set d(v) to the shortest directed path from v to t in the network G where the length of a path is the number of edges of the path. (In particular, set d(t) = 0).

                                This can be done in time O(|V| + |E|) by a breadth first search starting at t and using all edges in the opposite direction. The source s isn’t reached by this BFS.

                                We initialize d(s) by setting d(s) = |V|.</p>
                            </div>
                            <div>
                                <h3>Main loop</h3>
                                <p>As long as the queue containing the active nodes isn’t empty pop the first node v from the front of the queue and apply a push/relabel-operation to v.</p>
                            </div>
                            <div>
                                <h3>Check for admissible push operations</h3>
                                <p>While e(v) > 0 and the residual network G'=(V,E') contains an edge that is legal with respect to the current distance function ( i.e., there is an edge e' = (v, w) having d(v) = d(w) +  1 ) apply a push</p>
                            </div>
<!--                             The residual network G'=(V,E') around a node v can be constructed on the fly. For this, we have to consider both the incoming (u,v) as well as the outgoing (v,w) edges in E. -->
                            <div>
                                <h3>Push</h3>
                                <p>Push &delta; = min{e(v), c'(e')} amount of flow from v to w.</p>

                                <p>More precisely, if e' &in; E' is a forward edge with respect to an edge e of G, increase the preflow f(e) of e by &delta;, and if e' is a backward edge, then decrease the preflow f(e) of e by &delta;.</p>

                                <p>By doing so, e(v) is decreased by &delta;, and e(w) is increased by &delta;. If w &ne; s,t, and if w wasn't active before, w becomes active, and is added at the end of the queue containing the active nodes.</p>
                            </div>
                            <div>
                                <h3>Check for an admissible relabel operation</h3>
                                <p>If v has still excess, i.e., e(v) > 0, and if there is no legal edge emanating from v in the residual network, then apply a relabel operation. </p><!-- as described in the following, and add v at the end of the queue after that. -->
                            </div>
                            <div>
                                <h3>Relabel</h3>
                                <p>Increase the distance d(v) of v to the value</p>
                                <p>min{ d(w)+1 | (v,w) is edge of the residual network G'}</p>
                                <p>add v at the end of the queue after that.</p>
                            </div>
                            <div>
                                <h3>Finished</h3>
                                <p>The algorithm terminated with a maximum flow value of:</p>
                                <p id="finalflow" style="color:green"></p>
                            </div>
                        </div>
<!--var STATUS_SELECTSOURCE = id++;
    var STATUS_SELECTTARGET = id++;
    var STATUS_START = id++;
    var STATUS_INITPREFLOW = id++;
    var STATUS_INITDISTANCEFUNCTION = id++;
    var STATUS_MAINLOOP = id++;
    var STATUS_ADMISSIBLEPUSH = id++;
    var STATUS_PUSH = id++;
    var STATUS_ADMISSIBLERELABEL = id++;
    var STATUS_RELABEL = id++;
    var STATUS_FINISHED = id; -->
                        <div class="PseudocodeWrapper" id="ta_div_statusPseudocode">
                            <div><p>s &larr; pick(v)</p></div>
                            <div><p>t &larr; pick(v)</p></div>
                            <div><p>BEGIN</p></div>
                            <div><p>(* Initializing the preflow *)</p>
                                 <p> FOR ALL e  = (u,w) &isin;E DO</p>
                                 <p>    IF u == s THEN f(e) &larr; c(e)</p>
                                 <p>    ELSE f(e) &larr; 0</p>
                                 <p>    IF u == s AND w &ne; t THEN queue.add(w)</p></div>
                            <div><p>(* Initializing the distance function *)</p>
                                 <p> d(s) = |V|</p>
                                 <p> FOR ALL v != s &isin; V DO</p>
                                 <p>    d(v) &larr; number of segments on directed path to t</p></div>
                            <div><p>(* Main Loop *)</p>
                                 <p> WHILE queue &ne; &empty; DO</p>
                                 <p>    v &larr; queue.pop()</p></div>
                            <div><p>    WHILE  e(v) > 0 AND &exist; e'=(v,w) &isin; E' with d(v) == d(w) + 1</p></div>
                            <div><p>       (* PUSH *)</p>
                                 <p>       push min{e(v),c'(e')} flow from v to w</p>
                                 <p>       IF w != s,t AND w &notin; queue THEN queue.add(w)</p></div>
                            <div><p>     IF e(v) > 0 AND &#8708; e'=(v,w) &isin; E' with d(v) == d(w) + 1</p></div>
                            <div><p>       (* RELABEL *)</p>
                                 <p>       d(v) &larr; min{d(w)+1 | (v,w) &isin E'</p>
                                 <p>       queue.add(v)</p></div>
                            <div><p>END</p></div>

<!--                             <p> d(t) = 0</p> -->
<!--                             <p>    ELSE f(e)=0</p>
                                 <p>    IF u==s AND w != t THEN queue.add(w)</p> -->
<!--                             <p class="pseudocode" id="ta_p_l4">  FOR i = 2,..,n DO</p>
                            <p class="pseudocode" id="ta_p_l4">    d(v[i]) &larr; &#8734;, parent(v[i]) &larr; NULL</p> -->

<!--                             <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l2">  d(v[1]) &larr; 0</p>
                            <p class="pseudocode" id="ta_p_l3">  FOR j = 2,..,n DO</p>
                            <p class="pseudocode" id="ta_p_l4">    d(v[j]) &larr; &#8734;</p>
                            <p class="pseudocode" id="ta_p_l5">  FOR i = 1,..,(|V|-1) DO</p>
                            <p class="pseudocode" id="ta_p_l6">    FOR ALL (u,v) in E DO</p>
                            <p class="pseudocode" id="ta_p_l7">      d(v) &larr; min(d(v), d(u)+l(u,v))</p>
                            <p class="pseudocode" id="ta_p_l8">  FOR ALL (u,v) in E DO</p>
                            <p class="pseudocode" id="ta_p_l9">    IF d(v) > d(u) + l(u,v) DO</p>
                            <p class="pseudocode" id="ta_p_l10">      Message: "Negative Circle"</p>
                            <p class="pseudocode" id="ta_p_l11">END</p> -->

<!--                             <p class="pseudocode" id="ta_p_l1">BEGIN</p>
                            <p class="pseudocode" id="ta_p_l2">  IF Graph ungültig THEN END</p>
                            <p class="pseudocode" id="ta_p_l3">  start &larr; geeigneter Knoten</p>
                            <p class="pseudocode" id="ta_p_l4">  tour &larr; {start}</p>
                            <p class="pseudocode" id="ta_p_l5">  REPEAT</p>
                            <p class="pseudocode" id="ta_p_l6">    akt = start &larr; Knoten aus tour mit <br />                  unbesuchten Kanten</p>
                            <p class="pseudocode" id="ta_p_l7">    subtour &larr; {start}</p>
                            <p class="pseudocode" id="ta_p_l8">    DO</p>
                            <p class="pseudocode" id="ta_p_l9">      {akt, u} &larr; Suche unbesuchte Kante</p>
                            <p class="pseudocode" id="ta_p_l10">      subtour &larr; subtour &#8746; {u}</p>
                            <p class="pseudocode" id="ta_p_l11">      akt &larr; u</p>
                            <p class="pseudocode" id="ta_p_l12">    WHILE start &#8800; akt</p>
                            <p class="pseudocode" id="ta_p_l13">    Integriere subtour in tour</p>
                            <p class="pseudocode" id="ta_p_l14">  UNTIL tour ist Eulerweg/-tour</p>
                            <p class="pseudocode" id="ta_p_l15">END</p>  -->
                            <h3>Variable status</h3>
                            <table class="algoInformationen">
                                <tr>
                                    <th class="algoInfoTH"><span>v</span></th>
                                    <th class="algoInfoTH"><span>queue</span></th>
                                    <th class="algoInfoTH"><span>e'</span></th>
                                    <th class="algoInfoTH"><span>c'</span></th>
                                </tr>
                                <tr>
                                    <td id="ta_td_v" class="algoInfoTD">-</td>
                                    <td id="ta_td_queue" class="algoInfoTD">&#8709;</td>
                                    <td id="ta_td_e_dash" class="algoInfoTD">-</td>
                                    <td id="ta_td_c_dash" class="algoInfoTD">-</td>
                                </tr>
                            </table>
                        </div>
                        <div id="ta_div_statusLogger">
                            <h3>Log of algorithm execution</h3>
                            <div id="logger"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="ta_div_confirmTabChange" title="Algorithmus abbrechen?" class="tabChangeWarningDialog">
                <h2>Beim Wechsel des Tabs wird der Algorithmus abgebrochen.</h2>
                <p>Du kannst die Anwendung <a href="#" target="_blank" tabindex=-1> in einem anderen Browserfenster</a> öffnen, um parallel einen anderen Tab zu lesen.</p>
            </div>
        </div>

        <!-- TAB Beschreibung des Algorithmus -->
        <div id="tab_ti" style="display: none;">
            <div id="ti_div_Einfuehrungstext">
                <div class="BeispielbildContainer">
                    <img src="https://i1.wp.com/cs.stanford.edu/people/trevisan/cs261-11/network1.png" alt="Network " /><p>Network max flow <sup>1</sup></p><br />
<!--                     <img src="img/koenigsberg_degree.png" alt="Gerade (grün) und ungerade (rot) Grade" /><p>Gerade (<span style="color: green;">grün</span>) und ungerade Grade (<span style="color: red;">rot</span>)</p><br /> -->
<!--                     <img src="img/graph1.png" alt="Eulerscher Graph" /><p>Eulerscher Graph</p><br /> -->
<!--                     <img src="img/graph2.png" alt="Der erste gefundene Kreis (blau)" /><p>Der erste gefundene Kreis (<span style="color: #0000cc">blau</span>)</p><br /> -->
<!--                     <img src="img/graph3.png" alt="Zweiter Kreis (grün) und komplette Eulertour (a - c - e - f - c - d - b - a)" /><p>Zweiter Kreis (<span style="color: green;">grün</span>) und komplette Eulertour<br />(a - c - e - f - c - d - b - a)</p> -->
                </div>
                <h1>Shortest Paths</h1>
                <p>In many applications one wants to obtain the shortest path from a to b.
                Depending on the context, the length of the path does not necessarily have to be the length in meter: One can as well look at the cost of a path &ndash; both if we have to pay for using it &ndash; or if we receive some.</p>
                <p><strong>In general we speak of cost</strong>.
                Therefore one assigns cost to each part of the path &ndash; also called "edge".</p>
                <p>Dijkstra's Algorithm computes shortest &ndash; or cheapest paths, if all cost are positive numbers.
                However, if one allows negative numbers, the algorithm will fail.</p>
                <p>The Bellman-Ford Algorithm by contrast can also deal with negative cost.</p>
                <p>These can for example occur when a taxi driver receives more money for a tour than he spends on fuel. If he does not transport somebody, his cost are positive.</p>
                <h1>Idea of the Algorithm</h1>
<!--                 <div class="BeispielbildContainer">
                    <img id="ti_img_beispiel4_1" src="img/graph1.png" alt="Edge before update."><p>This edge is a short-cut:<br> We know that we have to pay 20 in order to go from the starting node to the left node. The path from the left to the right node has cost 1.<br> Therefore one can go from the starting node to the node on the right with a total cost of 21.</p>
                    <img id="ti_img_beispiel4_2" src="img/graph1.png" alt="Edge before update.">
                </div> -->
                <p>The Bellman-Ford Algorithm computes the <strong>cost</strong> of the cheapest paths from a starting node to all other nodes in the graph. Thus, he can also construct the paths afterwards.</p>
                <p>The algorithm proceeds in an interactive manner, by beginning with a bad estimate of the cost and then improving it until the correct value is found.</p>
                <p>The first estimate is:</p>
                <ul>
                    <li> <strong>The starting node has cost 0</strong>, as his distance to itself is obviously 0.
                    <li> <strong>All other node have cost infinity</strong>, which is the worst estimate possible.
                </ul>
                <p>Afterwards, the algorithm checks every edge for the following condition: <strong>Are the cost of the source of the edge plus the cost for using the edge smaller than the cost of the edge's target?</strong></p>
                <p>If this is the case, we have found a <strong>short-cut</strong>: It is more profitable to use the edge which was just checked, than using the path used so far. 
                    Therefore the cost of the edge's target get updated: They are set to the cost of the source plus the cost for using the edge (compare example on the right).</p>
                <p>Looking at all edges of the graph and updating the cost of the nodes is called a <strong>phase</strong>. Unfortunately, it is not sufficient to look at all edges only once. 
                    After the first phase, the cost of all nodes for which the shortest path only uses one edge have been calculated correctly. After two phases all paths that use at most two edges have been computed correctly, and so on.</p>
<!--                 <div class="BeispielbildContainer"><img id="ti_img_beispiel3" src="img/graph1.png" alt="Graph with distances.">
                    <p>The green path from the starting node is the cheapest path. It uses 3 edges.</p>
                </div> -->
                <p>How many phases ware necessary? To answer this question, the observation that <strong>a shortest path has to use less edges than there are nodes in the graph.</strong>
                    Thus, we need at most one phase less than the number of nodes in the graph. A shortest path that uses more edges than the number of nodes would visit some node twice and thus build a circle.</p>
                <h1>Construction of the shortest path</h1>
                <p>Each time when updating the cost of some node, the algorithm saves the edge that was used for the update as the <strong>predecessor</strong> of the node.</p>
                <p>At the end of the algorithm, the shortest path to each node can be constructed by going backwards using the predecessor edges until the starting node is reached.</p>
                <h1>Circles with negative weight</h1>
<!--                 <div class="BeispielbildContainer"><img id="ti_img_beispiel2" src="img/graph1.png" alt="Graph with negative circle."><p>A cheapest path had to use this circle infinitely often. The cost would be reduced in each iteration.</p></div> -->
                <p>If the graph contains a circle with a negative sum of edge weights &ndash; a <strong>Negative Circle</strong>, the algorithm probably will not find a cheapest path.</p>
                <p>As can be seen in the example on the right, paths in this case can be infinitely cheap &ndash; one keeps on going through the circle.</p>
                <p>This problem occurs if the negative circle can be reached from the starting node.
                    Luckily, the algorithm can detect whether a negative circle exists.
                    This is checked in the last step of the algorithm.</p>
                <p>A negative circle can be reached if and only if after iterating all phases, one can still find a short-cut. 
                    <strong>Therefore, at the end the algorithm checks one more time for all edges </strong>whether the cost of the source node plus the cost of the edge are less than the cost of the target node.
                    If this is the case for an edge, the message "Negative Circle found" is returned.</p>
                <p>One can even find the negative circle with the help of the predecessor edges: One just goes back until one traversed a circle (that had negative weight).</p>
                <h1>What now?</h1>
                <div class="Entscheidungsweg" id="ti_div_EntscheidungLeft">
                    <h3>Create a graph and play through the algorithm</h3>
                    <button id="ti_button_gotoDrawGraph">Try algorithm after creating a graph</button>
                    <button id="ti_button_gotoAlgorithm">Try algorithm on an example graph</button>
                </div>
                <br style="clear: both;" />
                <p style="font-size: 10px; text-align: right;"><a name="bridge_copyright"></a><sup>1</sup> Von Bogdan Giuşcă unter GNU Free Documentation License 1.2, vgl. <a href="http://http://commons.wikimedia.org/wiki/File:Konigsberg_bridges.png">Wikimedia</a>.</p>
            </div>
        </div>

       
        <!-- TAB Weiteres -->
        <div id="tab_tw" style="display: none;">
            <div id="tw_Accordion">
                <h3>Wie sieht der (Pseudo-)Code des Algorithmus aus?</h3>
                <div>
                    <pre><code>Eingabe: Ungerichteter Graph G=(V,E), keine oder genau zwei Knoten besitzen einen ungeraden Grad
Ausgabe: Eulertour/-weg als Liste von Knoten</code></pre>
<hr>
<pre>
<code>BEGIN
    IF Graph ungültig THEN END
    IF Graph semi-eulersch THEN
        start &larr; Knoten mit ungeradem Grad
    ELSE
        start &larr; beliebiger Knoten
    subtour &larr; &empty;
    tour &larr; {start}
    REPEAT
        start &larr;  Knoten aus tour mit unbesuchten Kanten
        subtour &larr; {start}
        akt = start
        DO
            {akt, u} &larr; Suche unbesuchte Kante von akt aus
            subtour &larr; subtour &#8746; {u}
            akt &larr; u
        WHILE start &#8800; akt
        Integriere subtour in tour
    UNTIL tour ist Eulerweg/-tour
END</code></pre>
            </div>

                                <h3>What is the pseudocode of the algorithm?</h3>
                <div><pre><code>Input: Weighted, undirected graph G=(V,E) with weight function l.
Output: A list {d(v[j]) : j = 1,..,n} containing the distances dist(v[1],v[j]) = d(v[j]),
         if there are no negative circles reachable from v[1]. 
         The message "Negative Circle" is shown, if a negative circle can be reached from v[1].</code></pre>
<hr><pre><code>
BEGIN
   d(v[1]) &larr; 0
   FOR j = 2,..,n DO
      d(v[j]) &larr; &#8734;
   FOR i = 1,..,(|V|-1) DO
      FOR ALL (u,v) in E DO
         d(v) &larr; min(d(v), d(u) + l(u,v))
   FOR ALL (u,v) in E DO
      IF d(v) > d(u) + l(u,v) DO
         Message: "Negative Circle"
END</code></pre></div>


                <h3>Wie schnell ist der Algorithmus?</h3>
                <div>
                    <h2>Geschwindigkeit von Algorithmen</h2>
                    <p>Die Geschwindigkeit von Algorithmen wird üblicherweise in der <strong>Anzahl an Einzelschritten</strong> gemessen, die der Algorithmus bei der Ausführung benötigt.</p>
                    <p>Einzelschritte sind beispielsweise:</p>
                    <ul>
                      <li>Zuweisungen &ndash; Weise Knoten 1 den Wert 20 zu.</li>
                      <li>Vergleiche  &ndash; Ist 20 größer als 23?</li>
                      <li>Vergleich und Zuweisung  &ndash; Falls 20 größer als 15 ist, setze Variable <var>n</var> auf 20.</li>
                      <li>Einfache Arithmetische Operationen &ndash; Was ist 5 + 5 ?</li>
                    </ul>
                    <p>Da es sehr schwierig sein kann, diese Einzelschritte exakt zu zählen, möchte man nur die ungefähre <strong>Größenordnung</strong> der Anzahl Schritte wissen. Man spricht auch von der <strong>Laufzeit</strong> des Algorithmus. Meistens ist es besonders interessant, zu wissen, wie die Geschwindigkeit des Algorithmus von der Größe der Eingabe (hier: Anzahl Kanten und Knoten im Graph) abhängt.</p>
                    <h2>Laufzeit des Hierholzer Algorithmus</h2>
                    <p>Wir gehen von einem Graphen \(G = (V, E)\) mit \(|V| = n\) und \(|E| = m\) aus. Der Algorithmus bestimmt im ersten Schritt eine erste Tour \(T\). Um die nächsten Subtouren zu bestimmen, muss der Algorithmus einen Knoten aus \(T\) finden, der noch unbesuchte Kanten besitzt. Dieser Knoten dient als Start für die folgenden Subtouren mit denen die Tour erweitert wird. Ausgehend von einer leeren initialen Tour, kann die Tour maximal um n Knoten erweitert werden. Nach jeder vollständigen Subtour wird ein neuer Startknoten für folgende Subtouren bestimmt. Bei der Prüfung auf unbesuchte Kanten müssen im ungünstigsten Fall m Kanten betrachtet werden. Damit besitzt der Algorithmus eine polynomielle Laufzeit von \(O(n*m)\).</p>
                    <p>Der Algorithmus kann weiter optimiert werden, indem man eine separate Adjazenzliste speichert, aus der bereits genutzte Kanten gelöscht werden. So muss man zur Überprüfung auf unbesuchte Kanten pro Knoten nicht jedes Mal alle Kanten betrachtet, sondern insgesamt jede Kante nur ein einziges Mal. Damit ist eine lineare Laufzeit von \(O(n+m)\) möglich.</p>
                    <p>Die gleiche Laufzeit wird außerdem benötigt, um zu prüfen, ob ein Graph eulersch ist und der Hierholzer Algorithmus überhaupt angewendet werden kann.</p>
                </div>


                <h3>How fast is the algorithm?</h3>
                <div>
                    <h2>Speed of the algorithms</h2>
                    <p>The speed of an algorithm is the <strong>total number of individual steps</strong> which are performed during the execution.</p>
                    <p>These steps are for example:</p>
                    <ul>
                        <li>Assignments &ndash; Set distance of a node to 20.
                        </li>
                        <li>Comparisons &ndash; Is 20 greater than 23?
                        </li>
                        <li>Comparison and assignment &ndash; If 20 is greater than 15, set variable
                            <var>n</var>
                            to 20
                        </li>
                        <li>Simple Arithmetic Operations &ndash; What is 5 + 5?
                        </li>
                    </ul>
                    <p>Since it can be very difficult to count all individual steps, it is desirable to only count the approximate magnitude of the number of steps. This is also called the running time of an algorithm. Particularly, it is interesting to know the running time of an algorithm based on the size of the input (in this case the number of the vertices and the edges of the graph).</p>
                    <h2>Running time of the Bellman-Ford Algorithm</h2>
                    <p>We assume that the algorithm is run on a graph with <var>n</var> nodes and <var>m</var> edges.</p>
                    <p>At the beginning, the value &#8734; is assigned to each node. We need <var>n</var> steps for that.</p>
                    <p>Then we do the <var>n-1</var> phases of the algorithm &ndash; one phase less than the number of nodes. 
                        In each phase, all edges of the graph are checked, and the distance value of the target node may be changed.
                        We can interpret this check and assignment of a new value as one step and therefore have <var>m</var> steps in each phase.
                        In total all phases together require <var>m &middot; (n-1)</var> steps.</p>
                    <p>Afterwards, the algorithm checks whether there is a negative circle, for which he looks at each edge once.
                        Altogether he needs <var>m</var> steps for the check.</p>
                    <p><strong>The total running time of the algorithm </strong> is of the magnitude <var>m &middot; n</var>, as the <var>n</var> steps at the beginning and the <var>m</var>
                        steps at the end can be neglected compared to the <var>m &middot; (n-1)</var> steps for the phases.</p>
                </div>
                <h3>How can one prove that the result is always correct?</h3>
                <div>
                    <h2>A mathematical proof</h2>
                    <p>In this section we will prove that the Bellman-Ford Algorithm always returns a correct result, if the graph does not contain negative circles that can be reached from the starting node.</p>
                    <h3>The principle of induction</h3>
                    <p>The proof is based on the principle of induction. We first prove that at the beginning of the first phase, the cost for at least one node have been calculated correctly. Then, we show that in each phase we improve the current estimates.
                    At the end of each phase, we thus know the correct cost for more nodes than at the beginning of the phase. Additionally, we do not destroy any information in the respective phase
                    &ndash; the estimates can only get better.</p>
                    <p>Finally, we conclude that we do not need as many phases as the number of nodes in order to compute the correct cost correctly.</p>
                    <h3>After phase <var>i</var> the following holds:</h3>
                    <p>The algorithm has &ndash; as an estimate &ndash; assigned to each node <var>u</var> maximally the length of the shortest path from the starting node to <var>u</var> that uses at most <var>i</var>
                    edges (if such a path exists).</p>
                    <p>Let us have a look at this statement in detail for a node <var>u</var> at the end of phase <var>i</var>:</p>
                    <p>If no path from the starting node to <var>u</var> that uses at most <var>i</var> edges exists, we do not know anything.</p>
                    <p>If a path from the starting node to <var>u</var> using at most <var>i</var> edges exists, we know that the cost estimate for <var>u</var>
                    is as high as the cost of the path or lower. The reason is the following: If we consider the path without its last edge, we yield a path using <var>i</var>-1 edges.
                    The cost of the path's last node has been calculated correctly in the last phase. In this phase we have considered all edges, including the last part of the path.
                    As we have updated the cost correctly when considering the last part of the path, the cost of the last node of the path (that is using <var>i</var> edges) correctly.</p>
                    <h3>The number of phases needed is smaller than the number of nodes.</h3>
                    <p>A path using at least as many edges as the number of nodes cannot be a shortest path if all circle have positive total weight. With each edge the path uses he "sees" another node (the target node of the edge).
                    Additionally, we have to count the starting node the path saw without using another edge. If he uses as many edges as the number of nodes, it has seen at least one node twice or &ndash; to rephrase it &ndash; has used a circle.
                    As we have assumed that all circles have positive weight, skipping the circle would have been shorter.</p>
                    <p>If there are circles with a total weight of 0, it simply is as expensive to use the circle than to not do it. 
                        In this case paths that use less edges than the number of nodes suffice as well.</p>
                </div>
                <h3>References</h3>
                <div>
                <h4>Literature</h4>
<dl>
<dt>[GT88]</dt><dd>Andrew V. Goldberg und Robert E. Tarjan. „A new approach to the maximum-flow problem“. In: J. Assoc. Comput. Mach. 35.4 (1988), S. 921–940. issn: 0004-5411. doi: 10.1145/48014.61051. url: <a href="http://dx.doi.org/10.1145/48014.61051">http://dx.doi.org/10.1145/48014.61051</a>.</dt>
<dt>[AMO93]</dt><dd>Ravindra K. Ahuja, Thomas L. Magnanti und James B. Orlin. Network flows. Theory, algorithms, and applications. Prentice Hall, Inc., Englewood Cliffs, NJ, 1993, S. xvi+846. isbn: 0-13-617549-X.</dt>
<!-- <dt>[ID05]</dt><dd>Stefan Irnich und Guy Desaulniers. „Shortest Path Problems with Resource Constraints“. English. In: Column Generation. Hrsg. von Guy Desaulniers, Jacques Desrosiers und MariusM. Solomon. Springer US, 2005, S. 33–65. isbn: 978-0-387-25485-2. doi: 10.1007/ 0-387-25486-2_2. url: http://dx.doi.org/10.1007/0-387-25486-2_2.</dt> -->
<dt>[Jun13]</dt><dd>Dieter Jungnickel. Graphs, networks and algorithms. Fourth. Bd. 5. Algorithms and Com- putation in Mathematics. Springer, Heidelberg, 2013, S. xx+675. isbn: 978-3-642-32277-8; 978-3-642-32278-5. doi: 10.1007/978-3-642-32278-5. url: http://dx.doi.org/10. 1007/978-3-642-32278-5.</dt>
<dt>[Cor09]</dt><dd>Thomas H. Cormen. Introduction to algorithms. MIT press, 2009.</dd>
<dl>

<h4>Web resources</h4>
                <ol>
<!--                 <li>Goldberg, Andrew V., and Robert E. Tarjan. "A new approach to the maximum-flow problem." Journal of the ACM (JACM) 35.4 (1988): 921-940.</li>
                <li>Ahuja, Ravindra K., Thomas L. Magnanti, and James B. Orlin. "Network flows. 1993." Pg 39: 193-196.</li>
                <li>Ahuja, Ravindra K., Thomas L. Magnanti, and James B. Orlin. Network flows. No. MIT-WP-2059-88. ALFRED P SLOAN SCHOOL OF MANAGEMENT CAMBRIDGE MA, 1988.</li>
                <li>Jungnickel, Dieter. Graphs, networks and algorithms. Heidelberg: Springer, 2008.</li>
                <li>Cormen, Thomas H. Introduction to algorithms. MIT press, 2009.</li> -->
                <li><a href="http://wwwmayr.in.tum.de/lehre/2013WS/algoprak/uebung/tutorial6.english.pdf">http://wwwmayr.in.tum.de/lehre/2013WS/algoprak/uebung/tutorial6.english.pdf</a></li>
                <li><a href="http://people.mpi-inf.mpg.de/~mehlhorn/DatAlg/Maxflow.pdf">http://people.mpi-inf.mpg.de/~mehlhorn/DatAlg/Maxflow.pdf</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Maximum_flow_problem">https://en.wikipedia.org/wiki/Maximum_flow_problem</a></li>
                <li><a href="https://lucatrevisan.wordpress.com/2011/02/04/cs261-lecture-9-maximum-flow/">https://lucatrevisan.wordpress.com/2011/02/04/cs261-lecture-9-maximum-flow/</a></li>
                <li><a href="https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-section-1/">https://www.topcoder.com/community/data-science/data-science-tutorials/maximum-flow-section-1/</a></li>
                </ol>
                </div>
                <h3>Where can I find more information about graph algorithms?</h3>
                <div><p>Other graph algorithms are explained on the <a href="http://www-m9.ma.tum.de/Allgemeines/Routenplanung">Website of Chair M9</a> of the TU München.</p>
                <p>Furthermore there is an interesting book about shortest paths: <a href="http://www-m9.ma.tum.de/Ruth/WebHome">Das Geheimnis des kürzesten Weges</a></p>
                <p><a href="http://www.ma.tum.de/Studium/StudieninteressierteEn">Studying mathematics at the TU München</a> answers all questions about graph theory (if an answer is known).</p>
                
            </div>
        </div>
    </div>
    <footer>
        <p class="Disclaimer">
            IDP Project of Adrian Haarbach at Chair M9 of Technische Universität München. <span id="year">2015</span> | <a href="http://www-m9.ma.tum.de/Allgemeines/Rechtliches">Terms of use</a> | <a href="http://www-m9.ma.tum.de/Allgemeines/Impressum">About Us</a> | <a href="mailto&#58;m&#46;ritter&#64;ma&#46;tum&#46;de&#63;subject&#61;M9&#45;Web&#45;Feedback">Suggestions</a>
        </p>
    </footer>
</body>